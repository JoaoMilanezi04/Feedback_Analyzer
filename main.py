import pandas as pd
from tqdm import tqdm
import sys
import os
from concurrent.futures import ThreadPoolExecutor, as_completed
import time
import json
import re

from gemini_processor import analisar_comentario_individual, gerar_resumo_executivo, configurar_ia
from web_extractor import extrair_comentarios_de_url

def carregar_comentarios():
    """Carrega coment√°rios de diferentes fontes dispon√≠veis."""
    print("üìÅ Escolha a fonte dos coment√°rios:")
    print("1. üåê Extrair de URL (Amazon, MercadoLivre, Google Play, etc.)")
    print("2. üìÑ Carregar de arquivo (CSV, TXT, JSON)")
    print("3. ‚úçÔ∏è  Inserir manualmente")
    
    opcao = input("\nEscolha uma op√ß√£o (1/2/3): ").strip()
    
    if opcao == "1":
        return extrair_de_url()
    elif opcao == "2":
        return carregar_de_arquivo()
    elif opcao == "3":
        return entrada_manual()
    else:
        print("‚ùå Op√ß√£o inv√°lida.")
        sys.exit(1)

def extrair_de_url():
    """Extrai coment√°rios de uma URL de produto."""
    print("\nüåê EXTRA√á√ÉO DE COMENT√ÅRIOS POR URL")
    print("=" * 40)
    print("Plataformas suportadas:")
    print("‚Ä¢ Amazon (produtos)")
    print("‚Ä¢ MercadoLivre (produtos)")
    print("‚Ä¢ Google Play (apps)")
    print("‚Ä¢ App Store (apps)")
    print("‚Ä¢ Sites gen√©ricos")
    print("=" * 40)
    
    url = input("\nüîó Cole a URL do produto: ").strip()
    
    if not url:
        print("‚ùå URL n√£o pode estar vazia.")
        sys.exit(1)
    
    # Validar se √© uma URL v√°lida
    url_pattern = re.compile(
        r'^https?://'  # http:// or https://
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+[A-Z]{2,6}\.?|'  # domain...
        r'localhost|'  # localhost...
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})'  # ...or ip
        r'(?::\d+)?'  # optional port
        r'(?:/?|[/?]\S+)$', re.IGNORECASE)
    
    if not url_pattern.match(url):
        print("‚ùå URL inv√°lida. Deve come√ßar com http:// ou https://")
        sys.exit(1)
    
    print(f"\nüöÄ Extraindo coment√°rios de: {url}")
    print("‚è≥ Isso pode levar alguns minutos...")
    
    try:
        df = extrair_comentarios_de_url(url)
        
        if df.empty:
            print("\n‚ùå Nenhum coment√°rio foi encontrado nesta URL.")
            print("üí° Dicas:")
            print("   ‚Ä¢ Verifique se a URL est√° correta")
            print("   ‚Ä¢ Alguns sites podem bloquear extra√ß√£o autom√°tica")
            print("   ‚Ä¢ Tente uma URL direta para a p√°gina de reviews/coment√°rios")
            sys.exit(1)
        
        return df
        
    except Exception as e:
        print(f"\n‚ùå Erro ao extrair coment√°rios: {e}")
        print("üí° Tente:")
        print("   ‚Ä¢ Verificar sua conex√£o com a internet")
        print("   ‚Ä¢ Usar uma URL diferente")
        print("   ‚Ä¢ Carregar coment√°rios de arquivo")
        sys.exit(1)

def carregar_de_arquivo():
    """Carrega coment√°rios de arquivos locais."""
    print("\nüìÑ CARREGAMENTO DE ARQUIVO")
    print("=" * 30)
    
    # Verificar diferentes formatos de arquivo
    arquivos_possiveis = [
        'feedback.csv',
        'comentarios.csv', 
        'reviews.csv',
        'avalia√ß√µes.csv',
        'comentarios.txt',
        'feedback.json'
    ]
    
    for arquivo in arquivos_possiveis:
        if os.path.exists(arquivo):
            print(f"‚úÖ Arquivo encontrado: {arquivo}")
            return carregar_arquivo(arquivo)
    
    print("‚ùå Nenhum arquivo encontrado.")
    print("üìù Arquivos suportados:")
    for arquivo in arquivos_possiveis:
        print(f"   ‚Ä¢ {arquivo}")
    
    # Permitir especificar arquivo manualmente
    arquivo_manual = input("\nüìÇ Digite o caminho do arquivo (ou Enter para sair): ").strip()
    
    if arquivo_manual and os.path.exists(arquivo_manual):
        return carregar_arquivo(arquivo_manual)
    else:
        print("‚ùå Arquivo n√£o encontrado.")
        sys.exit(1)

def carregar_arquivo(nome_arquivo):
    """Carrega coment√°rios de diferentes tipos de arquivo."""
    try:
        extensao = nome_arquivo.split('.')[-1].lower()
        
        if extensao == 'csv':
            df = pd.read_csv(nome_arquivo)
            # Verificar se tem as colunas necess√°rias
            if 'comentario' not in df.columns:
                # Tentar encontrar coluna de coment√°rios com nomes alternativos
                colunas_comentario = ['review', 'text', 'feedback', 'comment', 'mensaje', 'texto']
                for col in colunas_comentario:
                    if col in df.columns:
                        df['comentario'] = df[col]
                        break
                else:
                    print("‚ùå Arquivo CSV deve ter uma coluna 'comentario' ou similar.")
                    sys.exit(1)
            
            # Adicionar colunas padr√£o se n√£o existirem
            if 'data' not in df.columns:
                df['data'] = pd.Timestamp.now().strftime('%Y-%m-%d')
            if 'fonte' not in df.columns:
                df['fonte'] = 'Produto Web'
                
        elif extensao == 'txt':
            with open(nome_arquivo, 'r', encoding='utf-8') as f:
                linhas = f.readlines()
            
            comentarios = [linha.strip() for linha in linhas if linha.strip()]
            df = pd.DataFrame({
                'data': [pd.Timestamp.now().strftime('%Y-%m-%d')] * len(comentarios),
                'fonte': ['Produto Web'] * len(comentarios),
                'comentario': comentarios
            })
            
        elif extensao == 'json':
            with open(nome_arquivo, 'r', encoding='utf-8') as f:
                dados = json.load(f)
            
            if isinstance(dados, list):
                # Lista de coment√°rios
                if isinstance(dados[0], str):
                    comentarios = dados
                else:
                    comentarios = [item.get('comentario', item.get('text', str(item))) for item in dados]
            else:
                comentarios = [str(dados)]
                
            df = pd.DataFrame({
                'data': [pd.Timestamp.now().strftime('%Y-%m-%d')] * len(comentarios),
                'fonte': ['Produto Web'] * len(comentarios),
                'comentario': comentarios
            })
        
        print(f"‚úÖ Carregados {len(df)} coment√°rios de {nome_arquivo}")
        return df
        
    except Exception as e:
        print(f"‚ùå Erro ao carregar arquivo {nome_arquivo}: {e}")
        sys.exit(1)

def entrada_manual():
    """Permite entrada manual de coment√°rios."""
    print("\nüìù Inser√ß√£o manual de coment√°rios")
    print("Digite os coment√°rios (linha por linha). Digite 'FIM' para terminar:")
    
    comentarios = []
    while True:
        comentario = input(f"Coment√°rio {len(comentarios) + 1}: ").strip()
        if comentario.upper() == 'FIM':
            break
        if comentario:
            comentarios.append(comentario)
    
    if not comentarios:
        print("‚ùå Nenhum coment√°rio inserido.")
        sys.exit(1)
    
    df = pd.DataFrame({
        'data': [pd.Timestamp.now().strftime('%Y-%m-%d')] * len(comentarios),
        'fonte': ['Entrada Manual'] * len(comentarios),
        'comentario': comentarios
    })
    
    return df

def processar_comentarios_otimizado(comentarios, max_workers=8):
    print(f"[INFO] Processando {len(comentarios)} coment√°rios com {max_workers} workers...")
    
    resultados = [None] * len(comentarios)
    
    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        future_to_index = {
            executor.submit(analisar_comentario_individual, comentario): i 
            for i, comentario in enumerate(comentarios)
        }
        
        with tqdm(total=len(comentarios), desc="Processando") as pbar:
            for future in as_completed(future_to_index):
                index = future_to_index[future]
                try:
                    resultado = future.result(timeout=15)
                    resultados[index] = resultado
                except Exception as e:
                    resultados[index] = {
                        "sentimento": "Erro",
                        "categoria": "Erro", 
                        "resumo_curto": "Erro de processamento."
                    }
                pbar.update(1)
    
    return resultados

def main():
    print("üöÄ Analisador de Feedback para Produtos Web")
    print("=" * 50)
    print("üìä Analise coment√°rios de qualquer produto da web!")
    print("=" * 50)
    
    if not configurar_ia():
        print("‚ùå Erro ao configurar a IA.")
        sys.exit(1)

    # Carregar coment√°rios de forma flex√≠vel
    df = carregar_comentarios()
    
    if df.empty:
        print("‚ùå Nenhum coment√°rio para processar.")
        sys.exit(1)
    
    # Mostrar informa√ß√µes sobre os dados carregados
    print(f"\nüìä Resumo dos dados:")
    print(f"   ‚Ä¢ Total de coment√°rios: {len(df)}")
    print(f"   ‚Ä¢ Fontes: {', '.join(df['fonte'].unique())}")
    if 'data' in df.columns:
        print(f"   ‚Ä¢ Per√≠odo: {df['data'].min()} a {df['data'].max()}")
    
    # Permitir ao usu√°rio configurar o produto
    nome_produto = input("\nüè∑Ô∏è  Nome do produto/servi√ßo: ").strip()
    if not nome_produto:
        nome_produto = "Produto Analisado"

    print(f"\nüîÑ Analisando feedback de '{nome_produto}'...")
    print("‚ö° Usando processamento paralelo otimizado...")
    inicio = time.time()
    
    # Otimizado: mais workers e timeout menor
    resultados = processar_comentarios_otimizado(df['comentario'].tolist(), max_workers=10)
    
    fim = time.time()
    tempo_total = fim - inicio
    velocidade = len(df) / tempo_total if tempo_total > 0 else 0
    print(f"‚ö° An√°lise conclu√≠da em {tempo_total:.1f}s ({velocidade:.1f} coment√°rios/seg)")

    # Filtrar erros para estat√≠sticas mais precisas
    resultados_validos = [r for r in resultados if r['sentimento'] != 'Erro']
    print(f"üìä {len(resultados_validos)}/{len(resultados)} coment√°rios processados com sucesso")
    
    if not resultados_validos:
        print("‚ùå Nenhum coment√°rio foi processado com sucesso.")
        print("üí° Tente novamente ou verifique sua conex√£o com a API Gemini.")
        sys.exit(1)

    contagem_sentimentos = pd.Series([r['sentimento'] for r in resultados_validos]).value_counts()    
    contagem_categorias = pd.Series([r['categoria'] for r in resultados_validos]).value_counts()

    texto_estatisticas = "## üìä An√°lise Quantitativa\n\n"
    texto_estatisticas += "### Distribui√ß√£o de Sentimento:\n"
    texto_estatisticas += contagem_sentimentos.to_string() + "\n\n"
    texto_estatisticas += "### T√≥picos Mais Comuns:\n"
    texto_estatisticas += contagem_categorias.to_string()

    print("ü§ñ Gerando resumo executivo...")
    resumo_executivo = gerar_resumo_executivo(texto_estatisticas)

    print("üíæ Criando relat√≥rio...")
    nome_arquivo = f"relatorio_{nome_produto.replace(' ', '_').lower()}_{int(time.time())}.md"
    try:
        with open(nome_arquivo, "w", encoding="utf-8") as f:
            f.write(f"# üìã An√°lise de Feedback - {nome_produto}\n\n")
            f.write(f"**Produto/Servi√ßo:** {nome_produto}\n")
            f.write(f"**Processado em:** {time.strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"**Total de coment√°rios:** {len(df)}\n")
            f.write(f"**Coment√°rios v√°lidos:** {len(resultados_validos)}\n")
            f.write(f"**Tempo de processamento:** {tempo_total:.1f} segundos\n")
            f.write(f"**Velocidade:** {velocidade:.1f} coment√°rios/seg\n\n")
            f.write("## üöÄ Resumo Executivo\n")
            f.write(resumo_executivo)
            f.write("\n\n---\n\n")
            f.write(texto_estatisticas)
            f.write("\n\n---\n\n")
            f.write("## üí¨ Coment√°rios Analisados\n\n")
            
            for i, (idx, row) in enumerate(df.iterrows()):
                if i < len(resultados):
                    resultado = resultados[i]
                    status = "‚úÖ" if resultado['sentimento'] != 'Erro' else "‚ùå"
                    f.write(f"### {status} Coment√°rio {i+1}\n")
                    f.write(f"**Data:** {row['data']}\n")
                    f.write(f"**Fonte:** {row['fonte']}\n")
                    f.write(f"**Texto:** _{row['comentario']}_\n")
                    f.write(f"**Sentimento:** {resultado['sentimento']}\n")
                    f.write(f"**Categoria:** {resultado['categoria']}\n")
                    f.write(f"**Resumo:** {resultado['resumo_curto']}\n\n")

        print(f"‚úÖ Relat√≥rio salvo: {nome_arquivo}")
        
        # Mostrar resumo no terminal
        print("\n" + "="*50)
        print("üìä RESUMO R√ÅPIDO")
        print("="*50)
        print(f"Produto: {nome_produto}")
        print(f"Total processado: {len(resultados_validos)}/{len(df)} coment√°rios")
        print("\nSentimentos:")
        for sentimento, count in contagem_sentimentos.items():
            print(f"  ‚Ä¢ {sentimento}: {count}")
        print("\nCategorias:")
        for categoria, count in contagem_categorias.items():
            print(f"  ‚Ä¢ {categoria}: {count}")
        print("="*50)
        
    except Exception as e:
        print(f"‚ùå Erro ao criar relat√≥rio: {e}")
        sys.exit(1)
    
if __name__ == "__main__":
    main()